{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NICD Centre for Vaccines and Immunology: Wastewater Genomics","text":"<p>The National Institute for Communicable Diseases\u2019 Centre for Vaccines and Immunology (CVI) in South Africa conducts surveillance of various pathogens, including SARS-Cov-2, measles, rubella, hepatitis A, hepatitis E, polio, influenza A, and influenza B, using wastewater-based epidemiology and genomic techniques. Additionally, clinical data is gathered from patients in selected reference hospitals as part of this comprehensive surveillance initiative. The information generated through this surveillance program serves as a valuable resource, offering regular updates on the trends and impact associated with the monitored pathogens. These updates are made accessible to the public, the broader medical community, healthcare practitioners, and policymakers. This documentation page is intended to serve as a reference guide, outlining the procedures for conducting analyses  routinely performed in our reporting and publications.</p> <p>For more information, please visit the NICD website</p> <p>For more information on SARS-CoV-2 wastewater-based genomic epidemiology please click here</p>"},{"location":"labtat/","title":"Turnaround Times","text":""},{"location":"labtat/#laboratory-and-sequencing-turnaround-times","title":"Laboratory And Sequencing Turnaround Times","text":"<p>Timely reporting of sample test results is required to support the wastewater-based  surveillance of pathogens. This ensure that any changes in the transmission of pathogens circulating  within the population or even circulating variants may be detected in a timely manner. </p> <p>Laboratory turnaround times (tat) are plotted each week to help rapidly identify delays at various  points at which samples are processed. This helps us quickly identify what may be causing delays and  address any challenges which may be faced. </p> <p>There are two graphs generated: one for the time taken to produce the quantitative levels of SARS-CoV-2 in wastewater,  and the other for the time taken to produce the sequencing results for those samples. The graphs produced illustrate the number of samples collected and processed during each week as a bar graph, and a line graph representing the average turnaround  time of all samples during a given week. </p>"},{"location":"labtat/#setting-up","title":"Setting up","text":"<p>The graphs are produced using R version 4.2.2 or higher and the following packages are required to run the script: </p> <pre><code>library(ggthemes)\nlibrary(scales)\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(lubridate)\n</code></pre> <p>The read_excel() function will be used to import the the excel spreadsheet into a dataframe. The types of data within each column may be specified using col_types. The coloumns don't always have to specied,but sometimes dates may be imported as numeric values. So specifying the columns helps prevent that from happening. </p> <pre><code>water &lt;- read_excel(\"//nicdfiles/Shares/Centre for Vaccines and Immunology/2022/COVID-19/SACCESS database/SARS-CoV-2 quantitative/Genome Copy Report Log value/2023/Genome copies report 20220710.xlsx\", \n                col_types = c(\"text\", \"text\", \"text\", \n                              \"text\", \"text\", \"text\", \n                              \"numeric\", \"numeric\", \"text\",\n                              \"text\", \"text\", \"text\",\n                              \"numeric\", \"date\", \"text\",\n                              \"text\", \"text\", \"text\",\n                              \"numeric\", \"date\", \"text\", \n                              \"text\", \"numeric\", \"numeric\", \n                              \"numeric\", \"text\", \"text\", \n                              \"text\", \"numeric\", \"text\", \n                              \"text\", \"text\", \"date\",\"text\", \"text\", \n                              \"text\",\"text\", \"date\", \"text\",\n                              \"date\", \"text\", \"text\",\n                              \"text\", \"numeric\", \"text\", \n                              \"numeric\", \"text\", \"numeric\", \n                              \"text\", \"numeric\", \"text\", \n                              \"numeric\", \"numeric\", \"numeric\", \n                              \"numeric\", \"numeric\", \"numeric\", \n                              \"text\", \"text\", \"text\"))\n</code></pre>"},{"location":"labtat/#calculating-the-epidemiological-weeks-epiweeks","title":"Calculating the epidemiological weeks (epiweeks)","text":"<p>We now need to add in a column containing the epiweeks. To ensure that no errors occur in our original \"water\" dataframe while we perform some data wrangling, we'll create a second dataframe, which we'll call \"water1\"</p> <pre><code>water1&lt;- water\n</code></pre> <p>The strftime() function can be used to create a year and month column based on when the sample was collected </p> <pre><code>water1$year &lt;- strftime(water1$`Date sample collected`, \"%Y\") #Creating year column  \nwater1$month &lt;- strftime(water1$`Date sample collected`, \"%m\") #Creating month column\n</code></pre> <p>The epiweek may also be calculated using the lubridate to calculate the epiweek based on the date that the sample was collected. Lubricate requires that the date format be specified and since our dates are recorded as yyyy-mm-dd we'll specify that the formwat is ymd</p> <pre><code>water1$epiweek &lt;- lubridate::epiweek(ymd(water1$`Date sample collected`))\n</code></pre> <p>For most our reports we report the epiweeks with the year combined (e.g. 2023w45) We can create a column containing the combined year and epiweek. We start by creating a column with the week represented as a \"w\" </p> <pre><code>water1$week &lt;- \"w\" #added column with w\n</code></pre> <p>Week can then combine what's in the \"year\", \"week\" and \"epiweek\" column and then send it to a new variable called \"epiweek2\"</p> <pre><code>my_cols2 &lt;- c(\"year\", \"week\", \"epiweek\") #new data object with 3 columns combined\nwater1$epiweek2 &lt;- do.call(paste, c(water1[my_cols2],sep =\"\")) #created new variable using concat columns\n</code></pre>"},{"location":"labtat/#calculating-turnaround-times-for-quantitative-results","title":"Calculating turnaround times for quantitative results","text":"<p>Because we only started recording the tat during epiweek 18 of 2023, we have to filter out all other epiweeks </p> <pre><code>watertat &lt;- water1 %&gt;% \nfilter(epiweek2 == \"2023w18\" | epiweek2 == \"2023w19\" | epiweek2 == \"2023w20\" | \n        epiweek2 == \"2023w21\" |  epiweek2 == \"2023w22\"|  epiweek2 == \"2023w23\"|\n    epiweek2 == \"2023w24\"|epiweek2 == \"2023w25\"|  epiweek2 == \"2023w26\" | \n    epiweek2 == \"2023w27\"| epiweek2 == \"2023w28\"|epiweek2 == \"2023w29\" |\n    epiweek2 == \"2023w30\" |epiweek2 == \"2023w31\"| \n    epiweek2 == \"2023w32\" |epiweek2 == \"2023w33\"|\n    epiweek2 == \"2023w34\" |epiweek2 == \"2023w35\"|epiweek2 == \"2023w36\"|\n    epiweek2 == \"2023w37\")\n</code></pre> <p>The tat for each sample may then be calculated by calculating the difference in time by various processes conducted in the lab. The difference is calculated in days</p> <pre><code>watertat$pro_tat &lt;- difftime(watertat$`Date Processed`,watertat$`Date sample collected`, units = c(\"days\"))\nwatertat$lab_tat &lt;- difftime(watertat$`Date tested at Laboratory`,watertat$`Date Processed`, units = c(\"days\"))\nwatertat$overall_tat &lt;- difftime(watertat$`Date tested at Laboratory`,watertat$`Date sample collected`, units = c(\"days\"))\n</code></pre> <p>To calculate the mean tat for all samples given a specific epiweek </p> <pre><code>mean_pro &lt;- watertat%&gt;% # we specify which df we would like to use\ngroup_by(epiweek2)%&gt;% # we specify what we would like to group by \nsummarise(Meanpro=mean(pro_tat, na.rm = TRUE))\n\nmean_lab &lt;- watertat%&gt;% # we specify which df we would like to use\ngroup_by(epiweek2)%&gt;% # we specify what we would like to group by \nsummarise(Meanlab=mean(lab_tat, na.rm = TRUE))\n\nmean_overall &lt;- watertat%&gt;% # we specify which df we would like to use\ngroup_by(epiweek2)%&gt;% # we specify what we would like to group by \nsummarise(Meanoverall=mean(overall_tat, na.rm = TRUE))\n</code></pre> <p>Since we've calculated the tat, we need to created a new dataframe with the  mean tat and the number of samples collected during a given epiweek. To tabulate the number of samples collected during each epiweek we can do </p> <pre><code>freq_samples &lt;- watertat %&gt;%\ngroup_by(epiweek2)%&gt;%\ncount(epiweek2, na.rm=TRUE)\n</code></pre> <p>We then need create a new dataframe which contains the number of samples collected during each week and  how long it took to process those samples</p> <pre><code>tat_vs_freq &lt;- merge(mean_pro, mean_lab, by= \"epiweek2\", na.rm =TRUE)\ntat_vs_freq &lt;- merge(tat_vs_freq, mean_overall, by= \"epiweek2\", na.rm =TRUE)\ntat_vs_freq &lt;- merge(tat_vs_freq, freq_samples, by= \"epiweek2\", na.rm =TRUE)\n</code></pre> <p>Now that we have a dataframe (tat_vs_freq) that contains how many samples were collected during each epiweek and how long it took to process those samples,  we can plot that on a graph. </p> <p>To specify that the graph should be saved as a .png file, we can use the png() function and specify the path of the folder for which the file should be saved in. The dimensions of the graph may also be specified to your desired width and height. </p> <pre><code>png(\"path/to/file/quantitative.png\", \nwidth = 5*900,\nheight = 5*500,\nres = 300,\npointsize = 8)\n</code></pre> <p>To plot the graph, ggplot2 will be used. We first specify which dataframe will be used to build the graph:</p> <pre><code>tat_plot &lt;- ggplot(tat_vs_freq) +\n</code></pre> <p>To specify that we want to create a bar dark gray bar graph with epiweeks on the x-azis and number of samples collected (n) on the y-axis</p> <pre><code>geom_bar(aes(x=epiweek2, y=n),stat=\"identity\", fill=\"darkgray\",\n         colour=\"darkgray\")+\n</code></pre> <p>To create three line graphs on top on the bar graph which show the average time it takes for samples to be processed (meanpro), samples to be quantified in the lab (meanlab) as well as the overall time (meanoverall). The mean turnaround times will be  displayed on a secondary y-axis. Because the number of days is generally less than the number of samples collected, it affects  the scale between the two y-axes. We can then multiply the values of the y-axis by 10 to ensure that they will be visible when plotting.</p> <pre><code>geom_line(aes(x=epiweek2, y=Meanpro*10, colour= \"Meanpro\", group=1),stat=\"identity\", size=1.5)+\ngeom_line(aes(x=epiweek2, y=Meanlab*10, colour= \"Meanlab\", group=1),stat=\"identity\", size=1.5)+\ngeom_line(aes(x=epiweek2, y=Meanoverall*10, colour= \"Meanoverall\", group=1),stat=\"identity\", size=1.5)+\n</code></pre> <p>To manually change the colours and labels of each line graph produced we can used the scale_colour_manual() function</p> <pre><code>scale_colour_manual(labels = c(\"Sample Preparation\", \"Quantification\", \"Overall\"), \n                  breaks = c(\"Meanpro\", \"Meanlab\",\"Meanoverall\" ),\n                  values = c(\"forestgreen\", \"black\", \"skyblue\")) +\n\n\nscale_y_continuous(sec.axis=sec_axis(~ . /10,name=\"Mean TAT in days\\n\")) + \nlabs(x=\"Epiweek\",y=\"Number of samples collected\\n\")+\nggthemes::theme_hc()+\ntheme(\naxis.ticks.x= element_blank(), \naxis.text.x = element_text(angle = 90, hjust = 0, size = 20),\naxis.text.y = element_text(size = 20),\nlegend.position=\"bottom\",\nlegend.title = element_blank(),\ntext = element_text( size=20),\naxis.line.x = element_line(color=\"black\", size = 1),\naxis.line.y = element_line(color=\"black\", size = 1)) +\ngeom_text(aes(label = n, x=epiweek2, y=n), vjust = -0.5, colour = \"black\", size = 6)\n\ntat_plot\n\ndev.off()\n</code></pre>"},{"location":"labtat/#calculating-turnaround-times-for-sequencing-results","title":"Calculating turnaround times for sequencing results","text":"<pre><code>seq &lt;- read_excel(\"//nicdfiles/Shares/Centre for Vaccines and Immunology/2022/COVID-19/SACCESS database/Sequencing Tracking List/Sequencing tracking report.xlsx\",\n              col_types = c(\"text\", \"date\", \"date\", \n                             \"date\",\"text\", \"date\", \"date\", \"numeric\", \"numeric\", \"numeric\", \"date\", \"text\"))\n\nseq1 &lt;- seq\n\n#sub-setting the data so that if sample was repeated, and therefore\n#the sample id repeated, it will only keep last duplicate, i.e repeat\n\nseq2 &lt;- seq1[!duplicated(seq1$`Lab Number`), fromLast=T] #double check\n\nseq_water &lt;- merge(water1, seq2, by= \"Lab Number\", na.rm =TRUE)\n\nseq_water &lt;- seq_water %&gt;% \nfilter(epiweek2 == \"2023w18\" | epiweek2 == \"2023w19\" | epiweek2 == \"2023w20\" | \n       epiweek2 == \"2023w21\" |  epiweek2 == \"2023w22\"|  epiweek2 == \"2023w23\"|\n       epiweek2 == \"2023w24\"| epiweek2 == \"2023w25\"|  epiweek2 == \"2023w26\" |\n       epiweek2 == \"2023w27\" | epiweek2 == \"2023w28\" | epiweek2 == \"2023w29\"|\n       epiweek2 == \"2023w30\" |epiweek2 == \"2023w31\" | \n       epiweek2 == \"2023w32\" |epiweek2 == \"2023w33\"| \n       epiweek2 == \"2023w34\" |epiweek2 == \"2023w35\"|epiweek2 == \"2023w36\"|\n       epiweek2 == \"2023w37\"| epiweek2 == \"2023w38\")\n\n#calculate TAT for each sample\n\nseq_water$extraction_tat &lt;- difftime(seq_water$`Extraction Date`, \n                                 seq_water$`Date tested at Laboratory`\n                                 , units = c(\"days\"))\n\nseq_water$pcr_tat &lt;- difftime(seq_water$`PCR Date`, \n                          seq_water$`Extraction Date`, \n                          units = c(\"days\"))\n\nseq_water$tapestation_tat &lt;- difftime(seq_water$`Tapestation Date`, \n                                  seq_water$`PCR Date`, \n                                  units = c(\"days\"))\n\nseq_water$sequencing_tat &lt;- difftime(seq_water$`Date received from Sequencing`,\n                                 seq_water$`Date submitted for Sequencing`, \n                                 units = c(\"days\"))\n\nseq_water$seq_report_tat &lt;- difftime(seq_water$`Report Date`,\n                                 seq_water$`Date received from Sequencing`, \n                                 units = c(\"days\"))\n\nseq_water$overall &lt;- difftime(seq_water$`Report Date` ,seq_water$`Date tested at Laboratory`, units = c(\"days\"))\n\n\n#calculate mean TAT for each epiweek\n\nmean_extraction_tat &lt;- seq_water%&gt;% # we specify which df we would like to use\ngroup_by(epiweek2)%&gt;% # we specify what we would like to group by \nsummarise(Extraction=mean(extraction_tat, na.rm = TRUE))\n\nmean_pcr_tat &lt;- seq_water%&gt;% # we specify which df we would like to use\ngroup_by(epiweek2)%&gt;% # we specify what we would like to group by \nsummarise(PCR=mean(pcr_tat, na.rm = TRUE))\n\nmean_tapestation_tat &lt;- seq_water%&gt;% # we specify which df we would like to use\ngroup_by(epiweek2)%&gt;% # we specify what we would like to group by \nsummarise(Tapestation=mean(tapestation_tat, na.rm = TRUE))\n\nmean_sequencing_tat &lt;- seq_water%&gt;% # we specify which df we would like to use\ngroup_by(epiweek2)%&gt;% # we specify what we would like to group by \nsummarise(Sequencing=mean(sequencing_tat, na.rm = TRUE))\n\nmean_seq_report_tat &lt;- seq_water%&gt;% # we specify which df we would like to use\ngroup_by(epiweek2)%&gt;% # we specify what we would like to group by \nsummarise(`Sequencing Report`=mean(seq_report_tat, na.rm = TRUE))\n\nmean_overall &lt;- seq_water%&gt;% # we specify which df we would like to use\ngroup_by(epiweek2)%&gt;% # we specify what we would like to group by \nsummarise(Overall=mean(overall, na.rm = TRUE))\n\n\n#Tabulate number of samples we've received\n\nfreq_samples2 &lt;- seq_water %&gt;%\ngroup_by(epiweek2)%&gt;%\ncount(epiweek2, na.rm=TRUE)\n\n#create new df with mean TAT and numbers\n#merge only takes two values at time so we gonna merge two first then the last one \nseqtat_vs_freq &lt;- merge(mean_extraction_tat, mean_pcr_tat, by=\"epiweek2\", na.rm =TRUE)\nseqtat_vs_freq &lt;- merge(seqtat_vs_freq, mean_tapestation_tat, by=\"epiweek2\", na.rm =TRUE)\nseqtat_vs_freq &lt;- merge(seqtat_vs_freq, mean_sequencing_tat, by=\"epiweek2\", na.rm =TRUE)\nseqtat_vs_freq &lt;- merge(seqtat_vs_freq, mean_seq_report_tat, by=\"epiweek2\", na.rm =TRUE)\nseqtat_vs_freq &lt;- merge(seqtat_vs_freq, mean_overall, by=\"epiweek2\", na.rm =TRUE)\nseqtat_vs_freq &lt;- merge(seqtat_vs_freq, freq_samples2, by=\"epiweek2\", na.rm =TRUE)\n\n#convert seqtat_vs_freq df into long format\n\n#seqtat_vs_freq2 &lt;- seqtat_vs_freq %&gt;%\n              #gather(Lab, n, -c(epiweek2, n))\n\n#seqtat_vs_freq2 &lt;- seqtat_vs_freq2 %&gt;%\n        #filter(Lab == \"Meancore\" | Lab == \"Meanlab\")\n\n\n#Plot\n\npng(\"/path/to/file/sequencing.png\", \n    width = 5*900,\n    height = 5*500, \n    res = 300,\n    pointsize = 8)\n\ntat_plot2 &lt;- ggplot(seqtat_vs_freq) +\ngeom_bar(aes(x=epiweek2, y=n),stat=\"identity\", fill=\"darkgray\",\n       colour=\"darkgray\")+\ngeom_line(aes(x=epiweek2, y=Extraction, colour= \"Extraction\", group=1),stat=\"identity\", size=1.5) +\ngeom_line(aes(x=epiweek2, y=PCR, colour= \"PCR\", group=1),stat=\"identity\", size=1.5) +\ngeom_line(aes(x=epiweek2, y=Tapestation, colour= \"Tapestation\", group=1),stat=\"identity\", size=1.5) +\ngeom_line(aes(x=epiweek2, y=Sequencing, colour= \"Sequencing\", group=1),stat=\"identity\", size=1.5)+\ngeom_line(aes(x=epiweek2, y=`Sequencing Report`, colour= \"Sequencing Report\", group=1),stat=\"identity\", size=1.5)+\ngeom_line(aes(x=epiweek2, y=Overall, colour= \"Overall\", group=1),stat=\"identity\", size=1.5)+\nscale_y_continuous(sec.axis=sec_axis(~ . ,name=\"Mean TAT in days\\n\"))+ \nlabs(x=\"Epiweek\",y=\"Number of samples collected\\n\")+\nggthemes::theme_hc()+\ntheme(\n    axis.ticks.x= element_blank(), \n    axis.text.x = element_text(angle = 90, hjust = 0, size = 20),\n    axis.text.y = element_text(size = 20),\n    legend.position=\"bottom\",\n    legend.title = element_blank(),\n    text = element_text( size=20),\n    axis.line.x = element_line(color=\"black\", size = 1),\n    axis.line.y = element_line(color=\"black\", size = 1)) +\ngeom_text(aes(label = n, x=epiweek2, y=n), vjust = -0.5, colour = \"black\", size = 6)\n\ntat_plot2\n\ndev.off()\n</code></pre>"},{"location":"sample_maps/","title":"GIS graphs for Sample Tracking","text":"<p>When wastewater samples are collected, the RedCap Mobile App is used to capture  the sample collection forms. These forms contain information about when, where and  how a sample was collected.This helps us ensure that samples are collected from  the correct sites and assists in sample tracking. </p> <p>Since we have the location (longitude and latitute) of the samples being collected,  we can plot them on a map using R and Google Maps. Other GIS software, such as ArcGIS,  may also be used; however, for this tuturial we will only be using open source software. </p>"},{"location":"sample_maps/#setting-up","title":"Setting up","text":"<p>In order to run this script you will need R version 4.2.2 or higher. You will also need to register a Google API in order to be able to make use of Google services within R.  To register with google you can visit the Google Maps Platform</p> <p>Once registered, ensure that you enable your API. It is important to note that your API key should be kept private  and should not be shared with anyone else. This key will be used to connect with Google Maps using your R script. </p> <p>To get started, you will need the following packages to run the script: ggmap, rstudioapi, tidyverse, lubridate and ggrepel. </p> <p>If you do not already have these packages installed, you can simply use the install.packages() function. You can simply copy and paste the below and click \"Run\" to install the package: </p> <pre><code>install.packages(\"ggmap\")\n</code></pre> <p>Multiple packages can also be installed at the same time by creating a list of the packages to be installed using the c() function: </p> <pre><code>install.packages(c(\"ggmap\", \"rstudioapi\", \"tidyverse\", \"lubridate\", \"ggrepel\"))\n</code></pre> <p>Once you have installed a package in R, you don't need to install it again when you subsequently use R.  However, you do need to tell R which packages you would like to use to run the script.  We can do this using the library() function: </p> <pre><code>library(ggmap)\nlibrary(rstudioapi)\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(ggrepel)\n</code></pre> <p>Once we have loaded the libraries we would like to use, we have to connect to Google using our API key. We can do this using: </p> <pre><code>register_google(key = 'enter-your-key-here')\n</code></pre>"},{"location":"sample_maps/#preparing-our-data","title":"Preparing our data","text":"<p>Now we are ready to work with our data. As previously mentioned, this data is collected using RedCap. In order to obtain this data  you will need to export it from RedCap. The data exported is in the form of a .csv file.</p> <p>You can download an example dataset to practice with here: wastewater_sample_data.csv</p> <p>We can take that csv file and save it as a dataframe which we will call \"map\" using the read.csv() function: </p> <pre><code>map &lt;- read.csv(\"Path/to/the/file.csv\", check.names = F) #Replace the path with the path to the file on your computer\n</code></pre> <p>If you view the \"map\" dataframe, you will notice that each column name is separated by a fullstop. This is because spaces in  column headings were replace with a fullstop when we were reading in the csv file. For example: \"Sample Number\"  becomes \"Sample.Number.\". To make it a bit easier to work with, we are going to rename the columns we will be working with:</p> <pre><code>map$record_id &lt;- map$Sample.Number.\nmap$sam_site_id &lt;- map$Sample.Site.Identification.Number.\nmap$site_latitude &lt;- map$Site.Location..lat.\nmap$site_longitude &lt;- map$Site.Location..long.\nmap$sam_col_date &lt;- as.Date(map$Sample.Collection.Date) #the as.Date() function just ensures that the dates are being recognised as dates\nmap$sam_col_tim &lt;- map$Sample.Collection.Time.\n</code></pre> <p>Since we only want to work with these columns, we're going to filter out all the ones we don't need and select the ones we want to work with. This step isn't really that necessary, but helps keeps things tidy and is easier to work with: </p> <pre><code>map &lt;- map %&gt;% \n       select(record_id, sam_site_id, site_latitude, site_longitude, sam_col_date, sam_col_tim)\n</code></pre> <p>Since we report our findings using epidemiological weeks, or epiweeks, we want to add another column with the epiweeks.  We can use the sample collection date to calculate the epiweek: </p> <pre><code>map$epiweek &lt;- lubridate::epiweek(ymd(map$sam_col_date)) #ymd indicates that our dates are saved in the year-month-day format (e.g. 2023-09-15)\n</code></pre> <p>We also want to create a column which has both the year and epiweek (e.g. 2023w36). In order to produce this we first  have to create a column with the year, another column with the week and then finally concatenate the columns to create the new epiweek2 variable:</p> <pre><code>map$year &lt;- strftime(map$sam_col_date, \"%Y\") #Creating year column  \nmap$week &lt;- \"w\" #creating a week column with \"w\" representing the weeks. \nmy_cols &lt;- c(\"year\", \"week\", \"epiweek\") #creating a new data object which combines the 3 columns in the specified order\nmap$epiweek2 &lt;- do.call(paste, c(map[my_cols],sep =\"\")) #taking that data object and saving it in the newly created epiweek2 column\n</code></pre> <p>The \"map\" dataframe should now look like the example below. </p> <p> </p>"},{"location":"sample_maps/#generating-the-maps","title":"Generating the maps","text":"<p>Now that our data is in the format that we want, we can create maps of where the samples were created. The first map will show all points at which samples were collected.</p> <p>We first have to specify that we want to save the map as an image as well as the folder we would like the map to be stored</p> <pre><code>png(\"path/to/file/map1.png\", \n    width = 5*900, #specify width dimension\n    height = 5*500, #specify height dimension\n    res = 300, #specifying the resolution of the image\n    pointsize = 8)\n</code></pre> <p>Then we generate the site map. Because google map uses the location at the center of a map, we must first supply it with the coordinates at the center of our sample collection sites.  For our sample collection sites we use the following coordinates as the center of our map. </p> <p>City of Ekurhuleni: lon = 28.23570, lat = -25.99873</p> <p>City of Johannesburg:lon = lon = 27.91593 , lat = -26.31008</p> <p>City of Tshwane:lon = 28.12 , lat = -25.76257</p> <p>If you want to generate a map for a different city, you can simple use that city's coordinates as the center of your map.</p> <p>To generate a map of all samples collected in the City of Ekurhuleni we first have to tell Google when the center of our map is</p> <pre><code>coe_sites &lt;- ggmap(get_googlemap(center = c(lon = 27.91593 , lat = -26.31008),\n                             zoom = 12,\n                             maptype = \"hybrid\",\n                             color = \"color\")) +\n</code></pre> <p>To add points (red dots) where samples were collected onto the Google Maps, we use the coordinates  of each sample collected in the \"map\" dataframe we created. </p> <pre><code>geom_point(data = map, aes(x= site_longitude, y=site_latitude),\n         color = \"red\", #we specify the colour of our points\n         size= 2) + #we specify the size of our point\ntheme(axis.title = element_blank(), #This remove the title from the map\n    axis.text = element_blank(), #This removes coordinates from being displayed along the x- and y-axis\n    axis.ticks = element_blank()) #This removes any axis-ticks\n</code></pre> <p>To then generate the maps, we finally run: </p> <pre><code>coj_sites\ndev.off()\n</code></pre> <p>You should now have a map illustrating all sample collection points in the City of Ekurhuleni.</p> <p></p> <p>In order to generate a map showing samples collected during a specific  epiweek, as well as the time in which those samples were collected, we will  first create another dataframe called \"map2\" and filter for a specific epiweek: </p> <pre><code>map2 &lt;- map%&gt;% \nfilter(epiweek == 37)\n</code></pre> <p>Then we create a map of all the points collected during that epiweek: </p> <pre><code>png(\"path/to/file/map2.png\", \n    width = 5*900,\n    height = 5*500, \n    res = 300,\n    pointsize = 8)\n\ncoe_sites2 &lt;- ggmap(get_googlemap(center = c(lon = 28.23570, lat = -25.99873),\n                             zoom =12,\n                             scale = 2,\n                             maptype = \"hybrid\",\n                             color = \"color\")) +\ngeom_point(data = map2, aes(x= site_longitude, y=site_latitude), #ensure that you are using the filtered \"map2\" dataframe\n         color = \"red\", \n         size= 2) +\n</code></pre> <p>In addition to creating the map we want to add labels showing the sample collection times. Since the sample colletion times are also recorded on  the sample collection forms, we can use the geom_label_repel() function to convert those times into sample labels. Here we specify that for each sample, the longitude will be use as our x-coordinate, latitute for the y-coordinate and sample collection time as the label</p> <pre><code>geom_label_repel(data = map2, \n               aes(x= site_longitude, y=site_latitude, label = sam_col_tim), \n               size = 6)+ #specify size of the label\ntheme(axis.title = element_blank(),\n    axis.text = element_blank(),\n    axis.ticks = element_blank())\ncoe_sites2\ndev.off()\n</code></pre> <p>You should now have two maps illustrating the sample collection points. </p> <p></p>"}]}